<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="Content-Security-Policy" content="default-src * data: gap: content: https://ssl.gstatic.com; style-src * 'unsafe-inline'; script-src * 'unsafe-inline' 'unsafe-eval'">
  <script src="cordova.js"></script>
  <script src="components/loader.js"></script>
  <link rel="stylesheet" href="components/loader.css">
  <link rel="stylesheet" href="css/style.css">
  <!-- Firebase SDKの読み込み -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
  <script src="www/config.js"></script>
  <script>
    let postsRef;
    let postsListener = null;
    let currentEditId = null;   // 現在の編集対象ID
    let currentUser = null;     // ログイン中ユーザ

    // メッセージ表示
    function showMessage(message, type = 'success') {
      const messageArea = $('#messageArea');
      messageArea.html(`
        <div class="message ${type}">
          ${message}
        </div>
      `);
      setTimeout(() => { messageArea.empty(); }, 3000);
    }

    // 認証エラーメッセージ日本語化
    function getAuthErrorMessage(error){
      if (error.code) return `認証エラーが発生しました（${error.code}）`;
      if (error.message) return `エラーが発生しました：${error.message}`;
      return 'エラーが発生しました';
    }

    // 文字数カウンター（残り文字数表示＆ボタン自動無効化）
    // inputId: 入力textareaのID, counterId: カウンタ表示要素ID, maxLength: 最大文字数
    // buttonSelector: 送信ボタンのセレクタ（任意）
    function updateCharacterCount(inputId, counterId, maxLength, buttonSelector = null){
      const $input = $(`#${inputId}`);
      const $counter = $(`#${counterId}`);
      const $button = buttonSelector ? $(buttonSelector) : null;

      function refresh(){
        const length = $input.val().length;
        const remaining = maxLength - length;
        $counter.text(`残り ${remaining} 文字（最大 ${maxLength} 文字）`);
        if (remaining < 0){
          $counter.addClass('error');
          if ($button) $button.prop('disabled', true);
        } else {
          $counter.removeClass('error');
          // 空文字のときはボタン無効化（不正送信防止）
          if ($button) $button.prop('disabled', length === 0);
        }
      }

      // 入力イベントで更新
      $input.on('input', refresh);
      // 初期表示
      refresh();
    }

    // 入力バリデーション
    function validateContent(content){
      if (!content || !content.trim()){
        showMessage('投稿内容を入力してください', 'error');
        return false;
      }
      if (content.length > 1000){
        showMessage('投稿内容は1000文字以内で入力してください', 'error');
        return false;
      }
      return true;
    }

    // 認証フォームのバリデーション
    function validateAuthInput(email, password, isRegister=false){
      if (!email || !email.trim()){
        showMessage('メールアドレスを入力してください', 'error');
        return false;
      }
      if (!password || !password.trim()){
        showMessage('パスワードを入力してください', 'error');
        return false;
      }
      if (isRegister && password.length < 6){
        showMessage('パスワードは6文字以上にしてください', 'error');
        return false;
      }
      return true;
    }

    // HTMLエスケープ（XSS対策）
    function escapeHtml(str){
      if (!str) return '';
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // 絶対時刻のフォーマット（ツールチップ用）
    function formatTimestamp(timestamp){
      const date = new Date(timestamp);
      return date.toLocaleString('ja-JP', {
        year: 'numeric', month: '2-digit', day: '2-digit',
        hour: '2-digit', minute: '2-digit'
      });
    }

    // 相対時刻表示（◯日前、◯時間前、◯分前、たった今）
    function formatRelativeTime(timestamp){
      const diffMs = Date.now() - timestamp;
      const sec = Math.floor(diffMs / 1000);
      if (sec < 60) return 'たった今';
      const min = Math.floor(sec / 60);
      if (min < 60) return `${min}分前`;
      const hr = Math.floor(min / 60);
      if (hr < 24) return `${hr}時間前`;
      const day = Math.floor(hr / 24);
      if (day < 7) return `${day}日前`;
      const week = Math.floor(day / 7);
      if (week < 5) return `${week}週間前`;
      const month = Math.floor(day / 30);
      if (month < 12) return `${month}か月前`;
      const year = Math.floor(day / 365);
      return `${year}年前`;
    }

    // 編集権限チェック
    function canEditPost(post){
      return currentUser && post.userId === currentUser.uid;
    }

    // 投稿要素生成
    function createPostElement(post){
      const canEdit = canEditPost(post);
      const actions = canEdit ? `
        <div class="post-actions">
          <button class="btn-edit" onclick="startEdit('${post.id}')">編集</button>
          <button class="btn-delete" onclick="deletePost('${post.id}')">削除</button>
        </div>
      ` : '';

      return `
        <div class="post" id="post-${post.id}">
          <div class="post-header">
            <span class="post-author">${escapeHtml(post.author)}</span>
            ${actions}
          </div>
          <div class="post-content">${escapeHtml(post.content)}</div>
          <div class="post-footer">
            <span class="post-time" title="${formatTimestamp(post.timestamp)}">
              ${formatRelativeTime(post.timestamp)}
            </span>
            ${post.updatedAt ? `
              <span class="post-updated" title="${formatTimestamp(post.updatedAt)}">
                （編集：${formatRelativeTime(post.updatedAt)}）
              </span>
            ` : ''}
          </div>
        </div>
      `;
    }

    // 投稿一覧描画
    function renderPosts(posts){
      const postsDiv = $('#postsList');
      postsDiv.empty();
      if (posts.length === 0){
        postsDiv.html('<p class="no-posts">投稿はありません</p>');
        return;
      }
      posts.forEach(post => postsDiv.append(createPostElement(post)));
    }

    // 投稿読み込み
    function loadPosts(){
      const sortOrder = $('#sortOrder').val();
      $('#loadingSpinner').show();
      if (postsListener){
        postsRef.off('value', postsListener);
        postsListener = null;
      }
      postsListener = postsRef.on('value', (snapshot) => {
        const posts = [];
        snapshot.forEach((child) => {
          posts.push({ id: child.key, ...child.val() });
        });
        if (sortOrder === 'newest') posts.sort((a,b) => b.timestamp - a.timestamp);
        else posts.sort((a,b) => a.timestamp - b.timestamp);
        renderPosts(posts);
        $('#loadingSpinner').hide();
      }, (error) => {
        console.error('Data fetch error:', error);
        showMessage('データの読み込みに失敗しました', 'error');
        $('#loadingSpinner').hide();
      });
    }

    // モーダル
    function showModal(id){ $(`#${id}`).fadeIn(200); $('body').addClass('modal-open'); }
    function closeModal(id){ $(`#${id}`).fadeOut(200); $('body').removeClass('modal-open'); }

    // 更新ハンドラ（モーダル）
    function handleUpdate(){
      if (!currentEditId) return;
      const content = $('#editContent').val();
      if (!validateContent(content)) return;
      const updates = { content, updatedAt: firebase.database.ServerValue.TIMESTAMP };
      postsRef.child(currentEditId).update(updates)
        .then(() => {
          showMessage('投稿を更新しました');
          closeModal('editModal');
          animateUpdate(currentEditId);
          currentEditId = null;
        })
        .catch((error) => {
          showMessage('更新に失敗しました：' + error.message, 'error');
        });
    }

    // 削除ハンドラ（モーダル）
    function handleDelete(){
      if (!currentEditId) return;
      const postElement = $(`#post-${currentEditId}`);
      postElement.addClass('deleting');
      postsRef.child(currentEditId).remove()
        .then(() => {
          showMessage('投稿を削除しました');
          closeModal('deleteModal');
          currentEditId = null;
        })
        .catch((error) => {
          showMessage('削除に失敗しました：' + error.message, 'error');
          postElement.removeClass('deleting');
        });
    }

    // 外側クリック／ESCでモーダルを閉じる
    $(document).on('click', '.modal-overlay', function(){ closeModal($(this).parent().attr('id')); });
    $(document).on('keydown', (e) => { if (e.key === 'Escape'){ $('.modal:visible').each(function(){ closeModal(this.id); }); }});

    // 編集開始
    function startEdit(postId){
      currentEditId = postId;
      const post = $(`#post-${postId}`);
      const content = post.find('.post-content').text();
      $('#editContent').val(content);
      updateCharacterCount('editContent', 'editContentCount', 1000);
      showModal('editModal');
    }

    // 投稿作成
    function createPost(author, content){
      if (!currentUser){
        showMessage('投稿するにはログインが必要です', 'error');
        return;
      }
      if (!validateContent(content)) return;
      const button = $('#postButton');
      button.prop('disabled', true);
      const postData = {
        author: currentUser.email,      // メールアドレスを著者として保存
        content: content,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        userId: currentUser.uid
      };
      postsRef.push(postData)
        .then(() => {
          showMessage('投稿が完了しました！');
          $('#contentInput').val('');
          updateCharacterCount('contentInput', 'contentCount', 1000, '#postButton');
        })
        .catch((error) => {
          showMessage('投稿に失敗しました：' + error.message, 'error');
        })
        .finally(() => { button.prop('disabled', false); });
    }

    // 認証系
    function login(email, password){
      if (!validateAuthInput(email, password)) return;
      const button = $('#loginButton');
      button.prop('disabled', true);
      firebase.auth().signInWithEmailAndPassword(email, password)
        .then(() => { showMessage('ログインしました'); clearAuthForm(); })
        .catch((error) => { showMessage(getAuthErrorMessage(error), 'error'); })
        .finally(() => { button.prop('disabled', false); });
    }
    function register(email, password){
      if (!validateAuthInput(email, password, true)) return;
      const button = $('#registerButton');
      button.prop('disabled', true);
      firebase.auth().createUserWithEmailAndPassword(email, password)
        .then(() => { showMessage('アカウントを作成しました'); clearAuthForm(); })
        .catch((error) => { showMessage(getAuthErrorMessage(error), 'error'); })
        .finally(() => { button.prop('disabled', false); });
    }
    function logout(){
      firebase.auth().signOut()
        .then(() => { showMessage('ログアウトしました'); })
        .catch(() => { showMessage('ログアウトに失敗しました', 'error'); });
    }
    function clearAuthForm(){ $('#loginEmail').val(''); $('#loginPassword').val(''); }

    // UI更新
    function updateUI(user){
      if (user){
        $('.logged-in').show();
        $('.logged-out').hide();
        $('#userEmail').text(user.email);
      } else {
        $('.logged-in').hide();
        $('.logged-out').show();
        $('#userEmail').text('');
      }
    }

    // 初期化
    $(function(){
      try {
        firebase.initializeApp(firebaseConfig);
        postsRef = firebase.database().ref('posts');
      } catch (error){
        console.error('Firebase initialization error:', error);
        showMessage('Firebaseの初期化に失敗しました', 'error');
      }

      firebase.auth().onAuthStateChanged((user) => { currentUser = user; updateUI(user); loadPosts(); });

      // 文字数カウンター初期化（投稿ボタン連動）
      updateCharacterCount('contentInput', 'contentCount', 1000, '#postButton');

      // 投稿
      $('#postButton').on('click', () => {
        const contentVal = $('#contentInput').val();
        createPost(null, contentVal);
      });

      // 認証
      $('#loginButton').on('click', () => { login($('#loginEmail').val(), $('#loginPassword').val()); });
      $('#registerButton').on('click', () => { register($('#loginEmail').val(), $('#loginPassword').val()); });
      $('#logoutButton').on('click', logout);

      // 並び順変更
      $('#sortOrder').on('change', loadPosts);
      loadPosts();
    });

    // クリーンアップ
    window.addEventListener('unload', () => {
      if (postsListener){ postsRef.off('value', postsListener); postsListener = null; }
    });
  </script>
</head>
<body>
  <div class="container">
    <h1>掲示板アプリ</h1>

    <div id="messageArea"></div>

    <!-- 認証フォーム（未ログイン時） -->
    <div class="auth-container logged-out">
      <div class="form-group">
        <label for="loginEmail">メールアドレス</label>
        <input type="email" id="loginEmail" class="form-control" placeholder="example@example.com">
      </div>
      <div class="form-group">
        <label for="loginPassword">パスワード</label>
        <input type="password" id="loginPassword" class="form-control" placeholder="6文字以上">
        <small class="help-text">※新規登録時は6文字以上</small>
      </div>
      <div class="button-group">
        <button id="loginButton" class="btn-primary">ログイン</button>
        <button id="registerButton" class="btn-secondary">新規登録</button>
      </div>
    </div>

    <!-- ログイン情報（ログイン時） -->
    <div class="user-info logged-in">
      <span>ログイン中：<span id="userEmail"></span></span>
      <button id="logoutButton" class="btn-secondary">ログアウト</button>
    </div>

    <!-- 投稿フォーム（ログイン時） -->
    <div class="post-form logged-in">
      <div class="form-group">
        <label for="contentInput">投稿内容</label>
        <textarea id="contentInput" class="form-control" placeholder="投稿内容を入力してください"></textarea>
        <small class="character-count" id="contentCount">残り 1000 文字（最大 1000 文字）</small>
      </div>
      <div class="button-group">
        <button id="postButton" class="btn-primary" disabled>投稿する</button>
      </div>
    </div>

    <!-- 投稿一覧 -->
    <div class="posts-container">
      <h2>投稿一覧</h2>
      <div class="posts-control">
        <select id="sortOrder" class="form-control">
          <option value="newest">新しい順</option>
          <option value="oldest">古い順</option>
        </select>
      </div>
      <div id="postsList"></div>
      <div id="loadingSpinner" class="loading-spinner" style="display:none;">
        <div class="spinner"></div>
        <p>読み込み中...</p>
      </div>
    </div>
  </div>

  <!-- 編集モーダル -->
  <div id="editModal" class="modal">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>投稿を編集</h3>
        <button class="modal-close" onclick="closeModal('editModal')">×</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <textarea id="editContent" class="form-control"></textarea>
          <small class="character-count" id="editContentCount">残り 1000 文字（最大 1000 文字）</small>
        </div>
      </div>
      <div class="modal-footer">
        <button onclick="handleUpdate()" class="btn-primary">更新</button>
        <button onclick="closeModal('editModal')" class="btn-cancel">キャンセル</button>
      </div>
    </div>
  </div>

  <!-- 削除モーダル -->
  <div id="deleteModal" class="modal">
    <div class="modal-overlay"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3>投稿の削除</h3>
        <button class="modal-close" onclick="closeModal('deleteModal')">×</button>
      </div>
      <div class="modal-body">
        <p>この投稿を削除してもよろしいですか？</p>
        <p class="text-danger">この操作は取り消せません。</p>
      </div>
      <div class="modal-footer">
        <button onclick="handleDelete()" class="btn-danger">削除</button>
        <button onclick="closeModal('deleteModal')" class="btn-cancel">キャンセル</button>
      </div>
    </div>
  </div>
</body>
</html>

css/style.css（追補・必要箇所）
/* 文字数カウンター */
.character-count { color: #666; }
.character-count.error { color: #d33; font-weight: bold; }

/* 投稿フッターの時刻 */
.post-footer { margin-top: 6px; color: #666; font-size: 0.9em; }
.post-updated { margin-left: 8px; color: #888; }

/* 更新アニメーション／削除中 */
.post.updated { animation: flash 1s; }
@keyframes flash { 0% { background: #fff3cd; } 100% { background: transparent; } }
.post.deleting { opacity: 0.4; }

